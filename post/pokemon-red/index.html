<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>游戏安全初探: 从Pokemon火红开始 | kotori的菜园</title>
<link rel="shortcut icon" href="https://kotoriseed.github.io//favicon.ico?v=1718591155332">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://kotoriseed.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="游戏安全初探: 从Pokemon火红开始 | kotori的菜园 - Atom Feed" href="https://kotoriseed.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-PJDEM99E9P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PJDEM99E9P');
</script>


    <meta name="description" content="
一直都很想接触一下逆向相关的东西，但是技术太有限了，只能先从简单的方面入手
你问我为什么从Pokemon FireRed开始？这可是爷的青春！

0x00 提取GBA的BINARY
在github上可以找到火红的整个项目代码：https:..." />
    <meta name="keywords" content="逆向,游戏安全" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://kotoriseed.github.io/">
  <img class="avatar" src="https://kotoriseed.github.io//images/avatar.png?v=1718591155332" alt="">
  </a>
  <h1 class="site-title">
    kotori的菜园
  </h1>
  <p class="site-description">
    挑战者贵为永恒黄金
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/friends" class="menu">
          友链
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              游戏安全初探: 从Pokemon火红开始
            </h2>
            <div class="post-info">
              <span>
                2023-03-19
              </span>
              <span>
                30 min read
              </span>
              
                <a href="https://kotoriseed.github.io/tag/EhITNGS5Q/" class="post-tag">
                  # 逆向
                </a>
              
                <a href="https://kotoriseed.github.io/tag/BuG7-YeHxG/" class="post-tag">
                  # 游戏安全
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <blockquote>
<p>一直都很想接触一下逆向相关的东西，但是技术太有限了，只能先从简单的方面入手</p>
<p><del>你问我为什么从Pokemon FireRed开始？这可是爷的青春！</del></p>
</blockquote>
<h1 id="0x00-提取gba的binary">0x00 提取GBA的BINARY</h1>
<p>在github上可以找到火红的整个项目代码：<a href="https://github.com/pret/pokefirered">https://github.com/pret/pokefirered</a></p>
<p>这无疑是减少了巨量的逆向工作量，but更多的时候我们都需要从0开始，所以我还是打算从提取binary这一步做起。</p>
<p>这里需要用到一个工具：<strong>no$gba</strong> ( Download：<a href="https://problemkaputt.github.io/gba.htm">https://problemkaputt.github.io/gba.htm</a> )</p>
<figure data-type="image" tabindex="1"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/17/6efc45566ceac.png" alt="1679061233844.png" loading="lazy"></figure>
<p>载入火红ROM的gba文件之后，转到0x08000000地址处，</p>
<p>使用no$gba菜单栏的 Utility -&gt; Binarydump to .bin FILE, 输入0x01000000 (16MB, 火红ROM的大小)代表要提取这么多数据。</p>
<p>接下来用ida打开，选择Processor type为<code>ARM Little-endian [ARM]</code></p>
<figure data-type="image" tabindex="2"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/17/29ec5bc85627e.png" alt="1679061466938.png" loading="lazy"></figure>
<p>然后从0x08000000处开始载入0x1000000个字节</p>
<figure data-type="image" tabindex="3"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/17/a84bbb5decf58.png" alt="1679061521278.png" loading="lazy"></figure>
<p>不过这个时候函数表还是空的，在IDA View-A视图中地址0x08000000的地方按p，就能分析出来很多函数了，并且也能正常反编译。</p>
<figure data-type="image" tabindex="4"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/17/d16e8c9a42e89.png" alt="1679063200200.png" loading="lazy"></figure>
<p>不过，直接这样看很难看出来这些函数究竟是在干什么，结合动调可能会好一些，但是效率任然会很低。</p>
<p>结合该项目现有的资源，我又找到了他的符号表，</p>
<p>(Download: <a href="https://raw.githubusercontent.com/pret/pokefirered/symbols/pokefirered.sym">https://raw.githubusercontent.com/pret/pokefirered/symbols/pokefirered.sym</a>)</p>
<p>类似于如下的格式：</p>
<pre><code>08000000 g 00000000 Start
08000000 l 00000000 .text
08000004 g 00000000 RomHeaderNintendoLogo
080000a0 l 00000000 RomHeaderGameTitle
080000ac g 00000000 RomHeaderGameCode
080000b0 l 00000000 RomHeaderMakerCode
080000b2 l 00000000 RomHeaderMagic
080000b3 l 00000000 RomHeaderMainUnitCode
080000b4 l 00000000 RomHeaderDeviceType
080000b5 l 00000000 RomHeaderReserved1
080000bc g 00000000 RomHeaderSoftwareVersion
080000bd l 00000000 RomHeaderChecksum
080000be l 00000000 RomHeaderReserved2
080000c4 g 00000000 GPIOPortData
080000c6 g 00000000 GPIOPortDirection
080000c8 g 00000000 GPIOPortReadEnable
08000100 l 00000000 .gcc2_compiled.
08000100 l 00000104 sGFRomHeader
08000204 g 00000000 start_vector
08000238 l 00000000 sp_usr
0800023c l 00000000 sp_irq
08000248 g 00000000 intr_main
0800031c l 00000000 loop
08000320 l 00000000 jump_intr
08000374 l 00000000 intr_return
080003a4 g 0000010c AgbMain
080003a4 l 00000000 .gcc2_compiled.
080004b0 l 00000014 UpdateLinkAndCallCallbacks
080004c4 l 0000004c InitMainCallbacks
08000510 l 00000034 CallCallbacks
08000544 g 00000014 SetMainCallback2

......
</code></pre>
<p><del>有了符号表和源码，我们就可以为所欲为啦。</del></p>
<p>至此，最基础的提取就告一段落了，后续将结合源码来看对它进行一些较为完整的逆向利用。</p>
<h1 id="0x01-实现财富自由浅析money反作弊机制">0x01 实现财富自由——浅析Money反作弊机制</h1>
<p>想要快速在一个游戏里获得快感，有一个朴素的方法就是暴富（）</p>
<p>所以我们的第一步就是弄清楚这个游戏的金钱系统是如何运转的，以及如何破解游戏的反作弊来让自己实现财富自由。</p>
<h2 id="初试">初试</h2>
<p>一开始使用了最暴力的方法来尝试修改现金：CheatEngine内存扫描</p>
<figure data-type="image" tabindex="5"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/965e36d320161.png" alt="1679119390931.png" loading="lazy"></figure>
<p>但是事情远远没有这么简单，这个地址几乎就是储存金钱的地方，但是每次重新进行了获取金钱的行为之后，它都会被复原到之前的值。所以说为了防止我们直接扫描内存来找到存储金钱的地址，开发者进行了一定的反作弊工作。</p>
<h2 id="分析">分析</h2>
<p>在源码中找到了<strong>money.c</strong>（<del>不讲武德</del>），有以下几个函数可以关注</p>
<pre><code class="language-c">#define MAX_MONEY 999999

u32 GetMoney(u32 *moneyPtr)
{
    return *moneyPtr ^ gSaveBlock2Ptr-&gt;encryptionKey;
}

void SetMoney(u32 *moneyPtr, u32 newValue)
{
    *moneyPtr = gSaveBlock2Ptr-&gt;encryptionKey ^ newValue;
}

bool8 IsEnoughMoney(u32 *moneyPtr, u32 cost)
{
    if (GetMoney(moneyPtr) &gt;= cost)
        return TRUE;
    else
        return FALSE;
}

void AddMoney(u32 *moneyPtr, u32 toAdd)
{
    u32 toSet = GetMoney(moneyPtr);

    // can't have more money than MAX
    if (toSet + toAdd &gt; MAX_MONEY)
    {
        toSet = MAX_MONEY;
    }
    else
    {
        toSet += toAdd;
        // check overflow, can't have less money after you receive more
        if (toSet &lt; GetMoney(moneyPtr))
            toSet = MAX_MONEY;
    }

    SetMoney(moneyPtr, toSet);
}

void RemoveMoney(u32 *moneyPtr, u32 toSub)
{
    u32 toSet = GetMoney(moneyPtr);

    // can't subtract more than you already have
    if (toSet &lt; toSub)
        toSet = 0;
    else
        toSet -= toSub;

    SetMoney(moneyPtr, toSet);
}
</code></pre>
<p>可以发现，程序通过<code>GetMoney</code>函数来计算出真实的金钱数，然后基于它实现了增加和减少金钱的函数。</p>
<p>增加金钱的时候有一个上限<code>MAX_MONEY</code>, 他的值是999999，所以说游戏内最多只能有这么多钱。</p>
<p>不难看出，反作弊的核心和我们利用的切入点都是GetMoney函数。</p>
<h2 id="简单利用">简单利用</h2>
<p>分析至此，有了几种利用思路。</p>
<h3 id="道具是我的钱也是我的">道具是我的，钱也是我的</h3>
<p>第一个便是从<code>RemoveMoney</code>入手，钱不够用的话，那就把扣钱也改成加钱！</p>
<p>结合符号表，找到了RemoveMoney中扣钱的指令，在<code>0809FE00</code>这个位置，</p>
<pre><code class="language-assembly">RAM:0809FE00                 CODE16
RAM:0809FE00
RAM:0809FE00 loc_809FE00                             ; CODE XREF: sub_809FDE8+12↑j
RAM:0809FE00                 SUBS            R1, R1, R4
RAM:0809FE02
RAM:0809FE02 loc_809FE02                             ; CODE XREF: sub_809FDE8+16↑j
RAM:0809FE02                 MOVS            R0, R5
RAM:0809FE04                 BL              sub_809FD84
RAM:0809FE08                 POP             {R4,R5}
RAM:0809FE0A                 POP             {R0}
RAM:0809FE0C                 BX              R0
</code></pre>
<p>我们把SUBS给patch成ADDS即可让所有开销都变成进账（）</p>
<figure data-type="image" tabindex="6"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/ab552a4fbe287.png" alt="1679121580616.png" loading="lazy"></figure>
<p>把<code>09 1B</code>改成<code>09 19</code>，然后去游戏里验证一下，</p>
<figure data-type="image" tabindex="7"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/7aee07f95984f.png" alt="1679121651894.png" loading="lazy"></figure>
<p>短短的几下购买，就赚得盆满钵满啦~</p>
<blockquote>
<p>上述方法其实是有一点不优美的，毕竟直接改掉了原本的游戏代码，改掉了代码之后，程序的hash值都已经发生了变化，万一你的小伙伴要求验证你的客户端hash值，一看就能发现客户端被篡改了，那么你再多的钱在他眼里也一文不值咯。</p>
</blockquote>
<h3 id="精准数值的修改">精准数值的修改</h3>
<p>玩家的money是与4字节的<code>gSaveBlock2Ptr-&gt;encryptionKey</code>异或之后存在内存中的，所以也说明了为什么之前用CE没办法直接扫描出来。</p>
<p>在很多函数中都能发现产生新encryptionKey并应用的代码，有一个思路是patch这个Random函数的返回值为0之类的固定值，不过这个方法任然有悖于不修改客户端的宗旨，所以并不继续尝试了。</p>
<pre><code class="language-c">// create a new encryption key
encryptionKey = (Random() &lt;&lt; 0x10) + (Random());
ApplyNewEncryptionKeyToAllEncryptedData(encryptionKey);
gSaveBlock2Ptr-&gt;encryptionKey = encryptionKey;
</code></pre>
<p>想要精准修改money，就需要把这个<strong>encryptionKey</strong>的值给得到。</p>
<figure data-type="image" tabindex="8"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/63413f1038014.png" alt="1679125232239.png" loading="lazy"></figure>
<p>通过动调，得到了这次的key是<code>0xAC728FDF</code>, 然后计算一下现在的钱加密后的值，试一下能不能在CE中找到</p>
<p><strong>10816 ^ 0xAC728FDF</strong>得到<strong>2893194655</strong>, 果然，直接搜出来了。</p>
<figure data-type="image" tabindex="9"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/3d8ecc49fd3a4.png" alt="1679125366858.png" loading="lazy"></figure>
<p>尝试修改之后重新加密，成功将钱变成<code>114514</code>，</p>
<figure data-type="image" tabindex="10"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/4abfc57b7d10d.png" alt="1679125543303.png" loading="lazy"></figure>
<p>（不要在意为什么人物性转了，动调encryptionkey的时候找到了存档结构体，就试了一下改变性别）</p>
<p>至此，我们已经能够通过纯手工的方法来任意修改金钱了（好耶）。</p>
<p>（另外，通过对encryptionKey的交叉引用，可以发现在存储背包item和powder之类的功能中也使用了它来加密信息）</p>
<figure data-type="image" tabindex="11"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/19/fbb77fe80c2d9.png" alt="1679200195333.png" loading="lazy"></figure>
<blockquote>
<p>不过，想要编写程序来自动化修改还有一定的难度，因为encryptionkey在内存中的地址并不固定，可能需要挖掘一下指针来帮助定位。</p>
</blockquote>
<h2 id="自动化修改money的一些尝试">自动化修改Money的一些尝试</h2>
<p>加密金钱用的<code>encryptionKey</code>位于<code>SaveBlock2</code>这个结构体中，</p>
<pre><code class="language-c">struct SaveBlock2
{
    /*0x000*/ u8 playerName[PLAYER_NAME_LENGTH + 1];
    /*0x008*/ u8 playerGender; // MALE, FEMALE
    /*0x009*/ u8 specialSaveWarpFlags;
    /*0x00A*/ u8 playerTrainerId[TRAINER_ID_LENGTH];
    /*0x00E*/ u16 playTimeHours;
    /*0x010*/ u8 playTimeMinutes;
    /*0x011*/ u8 playTimeSeconds;
    /*0x012*/ u8 playTimeVBlanks;
    /*0x013*/ u8 optionsButtonMode;  // OPTIONS_BUTTON_MODE_[NORMAL/LR/L_EQUALS_A]
    /*0x014*/ u16 optionsTextSpeed:3; // OPTIONS_TEXT_SPEED_[SLOW/MID/FAST]
              u16 optionsWindowFrameType:5; // Specifies one of the 20 decorative borders for text boxes
    /*0x15*/  u16 optionsSound:1; // OPTIONS_SOUND_[MONO/STEREO]
              u16 optionsBattleStyle:1; // OPTIONS_BATTLE_STYLE_[SHIFT/SET]
              u16 optionsBattleSceneOff:1; // whether battle animations are disabled
              u16 regionMapZoom:1; // whether the map is zoomed in
    /*0x018*/ struct Pokedex pokedex;
    /*0x090*/ u8 filler_90[0x8];
    /*0x098*/ struct Time localTimeOffset;
    /*0x0A0*/ struct Time lastBerryTreeUpdate;
    /*0x0A8*/ u32 gcnLinkFlags; // Read by Pokemon Colosseum/XD
    /*0x0AC*/ bool8 unkFlag1; // Set TRUE, never read
    /*0x0AD*/ bool8 unkFlag2; // Set FALSE, never read
    /*0x0B0*/ struct BattleTowerData battleTower;
    /*0x898*/ u16 mapView[0x100];
    /*0xA98*/ struct LinkBattleRecords linkBattleRecords;
    /*0xAF0*/ struct BerryCrush berryCrush;
    /*0xB00*/ struct PokemonJumpRecords pokeJump;
    /*0xB10*/ struct BerryPickingResults berryPick;
    /*0xB20*/ u8 filler_B20[0x400];
    /*0xF20*/ u32 encryptionKey;
}; // size: 0xF24

extern struct SaveBlock2 *gSaveBlock2Ptr;
</code></pre>
<p>除此之外，还有一个同等重要的结构体<code>SaveBlock1</code></p>
<pre><code class="language-c">struct SaveBlock1
{
    /*0x0000*/ struct Coords16 pos;
    /*0x0004*/ struct WarpData location;
    /*0x000C*/ struct WarpData continueGameWarp;
    /*0x0014*/ struct WarpData dynamicWarp;
    /*0x001C*/ struct WarpData lastHealLocation;
    /*0x0024*/ struct WarpData escapeWarp;
    /*0x002C*/ u16 savedMusic;
    /*0x002E*/ u8 weather;
    /*0x002F*/ u8 weatherCycleStage;
    /*0x0030*/ u8 flashLevel;
    /*0x0032*/ u16 mapLayoutId;
    /*0x0034*/ u8 playerPartyCount;
    /*0x0038*/ struct Pokemon playerParty[PARTY_SIZE];
    /*0x0290*/ u32 money;
    /*0x0294*/ u16 coins;
    /*0x0296*/ u16 registeredItem; // registered for use with SELECT button
    /*0x0298*/ struct ItemSlot pcItems[PC_ITEMS_COUNT];
    /*0x0310*/ struct ItemSlot bagPocket_Items[BAG_ITEMS_COUNT];
    /*0x03b8*/ struct ItemSlot bagPocket_KeyItems[BAG_KEYITEMS_COUNT];
    /*0x0430*/ struct ItemSlot bagPocket_PokeBalls[BAG_POKEBALLS_COUNT];
    /*0x0464*/ struct ItemSlot bagPocket_TMHM[BAG_TMHM_COUNT];
    /*0x054c*/ struct ItemSlot bagPocket_Berries[BAG_BERRIES_COUNT];
    /*0x05F8*/ u8 seen1[DEX_FLAGS_NO];
    /*0x062C*/ u16 berryBlenderRecords[3]; // unused
    /*0x0632*/ u8 unused_632[6];
    /*0x0638*/ u16 trainerRematchStepCounter;
    /*0x063A*/ u8 ALIGNED(2) trainerRematches[MAX_REMATCH_ENTRIES];
    /*0x06A0*/ struct ObjectEvent objectEvents[OBJECT_EVENTS_COUNT];
    /*0x08E0*/ struct ObjectEventTemplate objectEventTemplates[OBJECT_EVENT_TEMPLATES_COUNT];
    /*0x0EE0*/ u8 flags[NUM_FLAG_BYTES];
    /*0x1000*/ u16 vars[VARS_COUNT];
    /*0x1200*/ u32 gameStats[NUM_GAME_STATS];
    /*0x1300*/ struct QuestLog questLog[QUEST_LOG_SCENE_COUNT];
    /*0x2CA0*/ u16 easyChatProfile[EASY_CHAT_BATTLE_WORDS_COUNT];
    /*0x2CAC*/ u16 easyChatBattleStart[EASY_CHAT_BATTLE_WORDS_COUNT];
    /*0x2CB8*/ u16 easyChatBattleWon[EASY_CHAT_BATTLE_WORDS_COUNT];
    /*0x2CC4*/ u16 easyChatBattleLost[EASY_CHAT_BATTLE_WORDS_COUNT];
    /*0x2CD0*/ struct Mail mail[MAIL_COUNT];
    /*0x2F10*/ u8 additionalPhrases[NUM_ADDITIONAL_PHRASE_BYTES];
    /*0x2F18*/ OldMan oldMan; // unused
    /*0x2F54*/ struct DewfordTrend dewfordTrends[5]; // unused
    /*0x2F80*/ struct DayCare daycare;
    /*0x309C*/ u8 giftRibbons[GIFT_RIBBONS_COUNT];
    /*0x30A7*/ struct ExternalEventData externalEventData;
    /*0x30BB*/ struct ExternalEventFlags externalEventFlags;
    /*0x30D0*/ struct Roamer roamer;
    /*0x30EC*/ struct EnigmaBerry enigmaBerry;
    /*0x3120*/ struct MysteryGiftSave mysteryGift;
    /*0x348C*/ u8 unused_348C[400];
    /*0x361C*/ struct RamScript ramScript;
    /*0x3A08*/ struct RecordMixingGift recordMixingGift; // unused
    /*0x3A18*/ u8 seen2[DEX_FLAGS_NO];
    /*0x3A4C*/ u8 rivalName[PLAYER_NAME_LENGTH + 1];
    /*0x3A54*/ struct FameCheckerSaveData fameChecker[NUM_FAMECHECKER_PERSONS];
    /*0x3A94*/ u8 unused_3A94[64];
    /*0x3AD4*/ u8 registeredTexts[UNION_ROOM_KB_ROW_COUNT][21];
    /*0x3BA8*/ struct TrainerNameRecord trainerNameRecords[20];
    /*0x3C98*/ struct DaycareMon route5DayCareMon;
    /*0x3D24*/ u8 unused_3D24[16];
    /*0x3D34*/ u32 towerChallengeId;
    /*0x3D38*/ struct TrainerTower trainerTower[NUM_TOWER_CHALLENGE_TYPES];
}; // size: 0x3D68
</code></pre>
<p><code>SaveBlock1</code>和<code>SaveBlock2</code>是当前以及后续利用需要重点关注的结构体。</p>
<p>对<code>SaveBlock2</code>的分配，以及对<code>encryptionKey</code>的动态更新操作都在<strong>load_save.c</strong>中</p>
<pre><code class="language-c">void SetSaveBlocksPointers(void)
{
    u32 offset;
    struct SaveBlock1** sav1_LocalVar = &amp;gSaveBlock1Ptr;
    void *oldSave = (void *)gSaveBlock1Ptr;

    offset = (Random()) &amp; ((SAVEBLOCK_MOVE_RANGE - 1) &amp; ~3);

    gSaveBlock2Ptr = (void *)(&amp;gSaveBlock2) + offset;
    *sav1_LocalVar = (void *)(&amp;gSaveBlock1) + offset;
    gPokemonStoragePtr = (void *)(&amp;gPokemonStorage) + offset;

    SetBagPocketsPointers();
    SetQuestLogRecordAndPlaybackPointers(oldSave);
}

void MoveSaveBlocks_ResetHeap(void)
{
    void *vblankCB, *hblankCB;
    u32 encryptionKey;
    struct SaveBlock2 *saveBlock2Copy;
    struct SaveBlock1 *saveBlock1Copy;
    struct PokemonStorage *pokemonStorageCopy;

    // save interrupt functions and turn them off
    vblankCB = gMain.vblankCallback;
    hblankCB = gMain.hblankCallback;
    gMain.vblankCallback = NULL;
    gMain.hblankCallback = NULL;
    gMain.vblankCounter1 = NULL;
    
    saveBlock2Copy = (struct SaveBlock2 *)(gHeap);
    saveBlock1Copy = (struct SaveBlock1 *)(gHeap + sizeof(struct SaveBlock2));
    pokemonStorageCopy = (struct PokemonStorage *)(gHeap + sizeof(struct SaveBlock2) + sizeof(struct SaveBlock1));

    // backup the saves.
    *saveBlock2Copy = *gSaveBlock2Ptr;
    *saveBlock1Copy = *gSaveBlock1Ptr;
    *pokemonStorageCopy = *gPokemonStoragePtr;

    // change saveblocks' pointers
    SetSaveBlocksPointers(); // unlike Emerald, this does not use
                             // the trainer ID sum for an offset.

    // restore saveblock data since the pointers changed
    *gSaveBlock2Ptr = *saveBlock2Copy;
    *gSaveBlock1Ptr = *saveBlock1Copy;
    *gPokemonStoragePtr = *pokemonStorageCopy;

    // heap was destroyed in the copying process, so reset it
    InitHeap(gHeap, HEAP_SIZE);

    // restore interrupt functions
    gMain.hblankCallback = hblankCB;
    gMain.vblankCallback = vblankCB;

    // create a new encryption key
    encryptionKey = (Random() &lt;&lt; 0x10) + (Random());
    ApplyNewEncryptionKeyToAllEncryptedData(encryptionKey);
    gSaveBlock2Ptr-&gt;encryptionKey = encryptionKey;
}

void ApplyNewEncryptionKeyToHword(u16 *hWord, u32 newKey)
{
    *hWord ^= gSaveBlock2Ptr-&gt;encryptionKey;
    *hWord ^= newKey;
}

void ApplyNewEncryptionKeyToWord(u32 *word, u32 newKey)
{
    *word ^= gSaveBlock2Ptr-&gt;encryptionKey;
    *word ^= newKey;
}

void ApplyNewEncryptionKeyToAllEncryptedData(u32 encryptionKey)
{
    int i;

    for(i = 0; i &lt; NUM_TOWER_CHALLENGE_TYPES; i++)
        ApplyNewEncryptionKeyToWord(&amp;gSaveBlock1Ptr-&gt;trainerTower[i].bestTime, encryptionKey);

    ApplyNewEncryptionKeyToGameStats(encryptionKey);
    ApplyNewEncryptionKeyToBagItems_(encryptionKey);
    ApplyNewEncryptionKeyToBerryPowder(encryptionKey);
    ApplyNewEncryptionKeyToWord(&amp;gSaveBlock1Ptr-&gt;money, encryptionKey);
    ApplyNewEncryptionKeyToHword(&amp;gSaveBlock1Ptr-&gt;coins, encryptionKey);
}
</code></pre>
<p>每次切换场景之后<code>gSaveBlock2</code>的位置都会变化，<code>encryptionKey</code>的值也会重新随机，对内存搜索造成了巨大的阻碍。（跳动指针反作弊）</p>
<p>通过对GetMoney函数交叉引用，可以找到我们最终想要修改的moneyPtr位于<strong>gSaveBlock1</strong>中，对于encryptionKey，其实我们是没必要特地去leak的，如果知道了内存中存储money的地址，也知道我们现在已经拥有的money数量，就能直接计算出encryptionKey的值了。</p>
<p>按道理来说，想要找到gSaveBlock1的位置，直接从<code>0x03005008</code>，也就是<strong>gSaveBlock1Ptr</strong>，这个地方来读就好了，但是我们利用的是内存搜索，并不能获取到这里的值，所以这里我还经过了几次动调，找到了在内存中的<code>0x028FE108</code>处会稳定出现gSaveBlock1的值，并且也能根据gSaveBlock1的值稳定调出money的位置。（but这个地址如果重新打开模拟器，也会变，所以想用这个还是有点折磨的，需要再次调出来一个地址。调试的具体过程我就不说了，并不是很麻烦）</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c">#include &lt;windows.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    HWND hwnd;
    DWORD pid;
    HANDLE process;

    hwnd = FindWindow(NULL, TEXT(&quot;No$gba Debugger (Fullversion)&quot;));
    if (hwnd == NULL) {
        puts(&quot;window not found&quot;);
        getchar();
        exit(-1);
    }

    GetWindowThreadProcessId(hwnd, &amp;pid);
    process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    printf(&quot;[+] pid = %d\n&quot;, pid);

    DWORD gSaveBlock1Ptr = 0x28fe108;
    DWORD gSaveBlock1;
    DWORD moneyPtr;
    DWORD encryptionKey;
    DWORD *buf_recv = (DWORD *)malloc(0x1000 * sizeof(DWORD));
    DWORD moneyCur;  /* current money */
    DWORD moneyChg;  /* money you want to change */
    char tmp[0x20] = {};

    int n = ReadProcessMemory(process, (PCVOID)gSaveBlock1Ptr, buf_recv, 8, 0);
    gSaveBlock1 = buf_recv[0];
    printf(&quot;[+] gSaveBlock1 addr: 0x%x\n&quot;, gSaveBlock1);

    moneyPtr = gSaveBlock1 + 0x290 + 0x8b5100;
    ReadProcessMemory(process, (PCVOID)moneyPtr, buf_recv, 4, 0);
    printf(&quot;[+] money addr: 0x%x\n&quot;, moneyPtr);

    puts(&quot;[+] how many money now: &quot;);
    scanf(&quot;%s&quot;, tmp);
    moneyCur = atoi(tmp);

    encryptionKey = moneyCur ^ buf_recv[0];

    puts(&quot;[+] new money: &quot;);
    scanf(&quot;%s&quot;, tmp);
    moneyChg = atoi(tmp);
    moneyChg ^= encryptionKey;

    int result = WriteProcessMemory(process, (LPVOID)moneyPtr, &amp;moneyChg, 4, 0);
    if (result) {
        puts(&quot;[+] Change succesfully!&quot;);
    }

    system(&quot;pause&quot;);

    return 0;
}
</code></pre>
<h3 id="效果图">效果图</h3>
<p>我们现在有114514块钱，</p>
<figure data-type="image" tabindex="12"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/bda0468fa9ea9.png" alt="1679139002443.png" loading="lazy"></figure>
<p>输入现在的钱和想要得到的钱之后，在游戏里就能看到被成功修改了，也能正常花费出去。</p>
<figure data-type="image" tabindex="13"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/18/4dfff46a810b0.png" alt="1679139075138.png" loading="lazy"></figure>
<h1 id="0x02-很难不谈的变强话题获得强力宝可梦">0x02 很难不谈的变强话题——获得强力宝可梦</h1>
<p>熟悉宝可梦的玩家都知道，评判一个宝可梦是否优秀，可以从<code>等级</code>，<code>种族值</code>，<code>天赋值</code>，<code>努力值</code>，<code>性格</code>等方便来判断，如果有闲情雅致的话，还能追求一下他是否是闪光。</p>
<h2 id="分析-2">分析</h2>
<p>这一次，我们从宝可梦属性的源码开始分析，</p>
<pre><code class="language-c">struct PokemonSubstruct0
{
    u16 species;
    u16 heldItem;
    u32 experience;
    u8 ppBonuses;
    u8 friendship;
};

struct PokemonSubstruct1
{
    u16 moves[4];
    u8 pp[4];
};

struct PokemonSubstruct2
{
    u8 hpEV;
    u8 attackEV;
    u8 defenseEV;
    u8 speedEV;
    u8 spAttackEV;
    u8 spDefenseEV;
    u8 cool;
    u8 beauty;
    u8 cute;
    u8 smart;
    u8 tough;
    u8 sheen;
};

struct PokemonSubstruct3
{
 /* 0x00 */ u8 pokerus;
 /* 0x01 */ u8 metLocation;

 /* 0x02 */ u16 metLevel:7;
 /* 0x02 */ u16 metGame:4;
 /* 0x03 */ u16 pokeball:4;
 /* 0x03 */ u16 otGender:1;

 /* 0x04 */ u32 hpIV:5;
 /* 0x04 */ u32 attackIV:5;
 /* 0x05 */ u32 defenseIV:5;
 /* 0x05 */ u32 speedIV:5;
 /* 0x05 */ u32 spAttackIV:5;
 /* 0x06 */ u32 spDefenseIV:5;
 /* 0x07 */ u32 isEgg:1;
 /* 0x07 */ u32 abilityNum:1;

 /* 0x08 */ u32 coolRibbon:3;
 /* 0x08 */ u32 beautyRibbon:3;
 /* 0x08 */ u32 cuteRibbon:3;
 /* 0x09 */ u32 smartRibbon:3;
 /* 0x09 */ u32 toughRibbon:3;
 /* 0x09 */ u32 championRibbon:1;
 /* 0x0A */ u32 winningRibbon:1;
 /* 0x0A */ u32 victoryRibbon:1;
 /* 0x0A */ u32 artistRibbon:1;
 /* 0x0A */ u32 effortRibbon:1;
 /* 0x0A */ u32 marineRibbon:1; // never distributed
 /* 0x0A */ u32 landRibbon:1; // never distributed
 /* 0x0A */ u32 skyRibbon:1; // never distributed
 /* 0x0A */ u32 countryRibbon:1; // distributed during Pok茅mon Festa '04 and '05 to tournament winners
 /* 0x0B */ u32 nationalRibbon:1;
 /* 0x0B */ u32 earthRibbon:1;
 /* 0x0B */ u32 worldRibbon:1; // distributed during Pok茅mon Festa '04 and '05 to tournament winners
 /* 0x0B */ u32 unusedRibbons:4; // discarded in Gen 4
 /* 0x0B */ u32 eventLegal:1; // controls Mew &amp; Deoxys obedience; if set, Pok茅mon is a fateful encounter in FRLG &amp; Gen 4+ summary screens; set for in-game event island legendaries, some distributed events, and Pok茅mon from XD: Gale of Darkness.
};

union PokemonSubstruct
{
    struct PokemonSubstruct0 type0;
    struct PokemonSubstruct1 type1;
    struct PokemonSubstruct2 type2;
    struct PokemonSubstruct3 type3;
    u16 raw[6];
};

struct BoxPokemon
{
    u32 personality;
    u32 otId;
    u8 nickname[POKEMON_NAME_LENGTH];
    u8 language;
    u8 isBadEgg:1;
    u8 hasSpecies:1;
    u8 isEgg:1;
    u8 unused:5;
    u8 otName[PLAYER_NAME_LENGTH];
    u8 markings;
    u16 checksum;
    u16 unknown;

    union
    {
        u32 raw[12];
        union PokemonSubstruct substructs[4];
    } secure;
};

struct Pokemon
{
    struct BoxPokemon box;
    u32 status;
    u8 level;
    u8 mail;
    u16 hp;
    u16 maxHP;
    u16 attack;
    u16 defense;
    u16 speed;
    u16 spAttack;
    u16 spDefense;
};
</code></pre>
<p>可以发现Pokemon结构体的组成分为了两个大部分，一个部分是BoxPokemon结构体，我们这里称他为非面板值，剩下的部分就是面板值。</p>
<p>东西有点多，暂时不一一解释了。（其实这个源码取的名字已经很贴心了，大致都能看出来是什么）</p>
<p>要利用，就得先找出来这个结构体在程序中哪些地方被用上了。</p>
<p>一个比较显眼的地方是<code>gSaveBlock1</code>中的<code>struct Pokemon playerParty[PARTY_SIZE];</code>这个成员。<code>PARTY_SIZE</code>是6，很容易想到它就是当前背包里的6只宝可梦的信息。</p>
<p>对这个<code>playerParty</code>进行交叉引用，可以看到他来源于全局数组<code>gPlayerParty</code>，</p>
<pre><code class="language-c">void SavePlayerParty(void)
{
    int i;

    gSaveBlock1Ptr-&gt;playerPartyCount = gPlayerPartyCount;

    for (i = 0; i &lt; PARTY_SIZE; i++)
        gSaveBlock1Ptr-&gt;playerParty[i] = gPlayerParty[i];
}

void LoadPlayerParty(void)
{
    int i;

    gPlayerPartyCount = gSaveBlock1Ptr-&gt;playerPartyCount;

    for (i = 0; i &lt; PARTY_SIZE; i++)
        gPlayerParty[i] = gSaveBlock1Ptr-&gt;playerParty[i];
}
</code></pre>
<p>跟进<code>gPlayerParty</code>，可以发现在对战，赠送，发送到PC等等功能中，只要是涉及到对身上的Pokemon进行操作的地方都会用到它，并且往往都是配合<strong>GetMonData</strong>这个函数出现的。</p>
<p><code>GetMonData</code>被定义在pokemon.c中，</p>
<pre><code class="language-c">u32 GetMonData(struct Pokemon *mon, s32 field, u8 *data)
{
    u32 ret;

    switch (field)
    {
    case MON_DATA_STATUS:
        ret = mon-&gt;status;
        break;
    case MON_DATA_LEVEL:
        ret = mon-&gt;level;
        break;
    case MON_DATA_HP:
        ret = mon-&gt;hp;
        break;
    case MON_DATA_MAX_HP:
        ret = mon-&gt;maxHP;
        break;
    case MON_DATA_ATK:
        ret = GetDeoxysStat(mon, STAT_ATK);
        if (!ret)
            ret = mon-&gt;attack;
        break;
    case MON_DATA_DEF:
        ret = GetDeoxysStat(mon, STAT_DEF);
        if (!ret)
            ret = mon-&gt;defense;
        break;
    case MON_DATA_SPEED:
        ret = GetDeoxysStat(mon, STAT_SPEED);
        if (!ret)
            ret = mon-&gt;speed;
        break;
    case MON_DATA_SPATK:
        ret = GetDeoxysStat(mon, STAT_SPATK);
        if (!ret)
            ret = mon-&gt;spAttack;
        break;
    case MON_DATA_SPDEF:
        ret = GetDeoxysStat(mon, STAT_SPDEF);
        if (!ret)
            ret = mon-&gt;spDefense;
        break;
    case MON_DATA_ATK2:
        ret = mon-&gt;attack;
        break;
    case MON_DATA_DEF2:
        ret = mon-&gt;defense;
        break;
    case MON_DATA_SPEED2:
        ret = mon-&gt;speed;
        break;
    case MON_DATA_SPATK2:
        ret = mon-&gt;spAttack;
        break;
    case MON_DATA_SPDEF2:
        ret = mon-&gt;spDefense;
        break;
    case MON_DATA_MAIL:
        ret = mon-&gt;mail;
        break;
    default:
        ret = GetBoxMonData(&amp;mon-&gt;box, field, data);
        break;
    }
    return ret;
}
</code></pre>
<p>该函数会返回查询的Pokemon的对应信息，可以看到面板值全都是直接返回的，而非面板值使用了另一个函数<strong>GetBoxMonData</strong>来中转，它的定义如下（源码有点长，为了不影响我们的思路，删减了一部分）：</p>
<pre><code class="language-c">u32 GetBoxMonData(struct BoxPokemon *boxMon, s32 field, u8 *data)
{
    s32 i;
    u32 retVal = 0;
    struct PokemonSubstruct0 *substruct0 = NULL;
    struct PokemonSubstruct1 *substruct1 = NULL;
    struct PokemonSubstruct2 *substruct2 = NULL;
    struct PokemonSubstruct3 *substruct3 = NULL;

    if (field &gt; MON_DATA_ENCRYPT_SEPARATOR)
    {
        substruct0 = &amp;(GetSubstruct(boxMon, boxMon-&gt;personality, 0)-&gt;type0);
        substruct1 = &amp;(GetSubstruct(boxMon, boxMon-&gt;personality, 1)-&gt;type1);
        substruct2 = &amp;(GetSubstruct(boxMon, boxMon-&gt;personality, 2)-&gt;type2);
        substruct3 = &amp;(GetSubstruct(boxMon, boxMon-&gt;personality, 3)-&gt;type3);

        DecryptBoxMon(boxMon);

        if (CalculateBoxMonChecksum(boxMon) != boxMon-&gt;checksum)
        {
            boxMon-&gt;isBadEgg = 1;
            boxMon-&gt;isEgg = 1;
            substruct3-&gt;isEgg = 1;
        }
    }

    switch (field)
    {
    case MON_DATA_PERSONALITY:
        retVal = boxMon-&gt;personality;
        break;
    case MON_DATA_OT_ID:
        retVal = boxMon-&gt;otId;
        break;
    case MON_DATA_NICKNAME:
    {
        if (boxMon-&gt;isBadEgg)
        {
            for (retVal = 0;
                retVal &lt; POKEMON_NAME_LENGTH &amp;&amp; gText_BadEgg[retVal] != EOS;
                data[retVal] = gText_BadEgg[retVal], retVal++) {}

            data[retVal] = EOS;
        }
        else if (boxMon-&gt;isEgg)
        {
            StringCopy(data, gText_EggNickname);
            retVal = StringLength(data);
        }
        else if (boxMon-&gt;language == LANGUAGE_JAPANESE)
        {
            data[0] = EXT_CTRL_CODE_BEGIN;
            data[1] = EXT_CTRL_CODE_JPN;

            // FRLG changed i &lt; 7 to i &lt; 6
            for (retVal = 2, i = 0;
                i &lt; 6 &amp;&amp; boxMon-&gt;nickname[i] != EOS;
                data[retVal] = boxMon-&gt;nickname[i], retVal++, i++) {}

            data[retVal++] = EXT_CTRL_CODE_BEGIN;
            data[retVal++] = EXT_CTRL_CODE_ENG;
            data[retVal] = EOS;
        }
        else
        {
            for (retVal = 0;
                retVal &lt; POKEMON_NAME_LENGTH;
                data[retVal] = boxMon-&gt;nickname[retVal], retVal++){}

            data[retVal] = EOS;
        }
        break;
    }
    
    /* .................. */
            
    default:
        break;
    }

    if (field &gt; MON_DATA_ENCRYPT_SEPARATOR)
        EncryptBoxMon(boxMon);

    return retVal;
}
</code></pre>
<p>这个函数的信息量就非常大了，查询的范围（field）在<code>MON_DATA_ENCRYPT_SEPARATOR</code>控制的区域内的时候，函数会做两件事，对<code>boxMon</code>进行解密和计算<code>checksum</code>并验证合法性。checksum在验证失败的时候会让我们的宝可梦变成一个<code>badegg</code>，然后永久没法孵化，boxMon的加密让我们没法直接获取某些数据。对于这两个流程，我们来挨个分析一下。</p>
<p>先看一下<strong>CalculateBoxMonChecksum</strong>函数，</p>
<pre><code class="language-c">static u16 CalculateBoxMonChecksum(struct BoxPokemon *boxMon)
{
    u16 checksum = 0;
    union PokemonSubstruct *substruct0 = GetSubstruct(boxMon, boxMon-&gt;personality, 0);
    union PokemonSubstruct *substruct1 = GetSubstruct(boxMon, boxMon-&gt;personality, 1);
    union PokemonSubstruct *substruct2 = GetSubstruct(boxMon, boxMon-&gt;personality, 2);
    union PokemonSubstruct *substruct3 = GetSubstruct(boxMon, boxMon-&gt;personality, 3);
    s32 i;

    for (i = 0; i &lt; 6; i++)
        checksum += substruct0-&gt;raw[i];

    for (i = 0; i &lt; 6; i++)
        checksum += substruct1-&gt;raw[i];

    for (i = 0; i &lt; 6; i++)
        checksum += substruct2-&gt;raw[i];

    for (i = 0; i &lt; 6; i++)
        checksum += substruct3-&gt;raw[i];

    return checksum;
}
</code></pre>
<p>这个<code>checksum</code>是根据<code>boxMon-&gt;personality</code>，通过<code>GetSubStruct</code>计算出相关的四个substruct的地址，然后再用共用体secure将四个指针分成若干个32位无符号整数<code>raw[i]</code>来累加生成的。</p>
<p><code>GetSubStruct</code>内置了25种情况的跳表（对应25种性格）来完成绑定，原理简单的说就是选定四个地址的某四位取出来结合成一个新的地址，这里不深入讨论它的原理。</p>
<p>然后将目光放到对boxMon的加解密上，</p>
<pre><code class="language-c">static void EncryptBoxMon(struct BoxPokemon *boxMon)
{
    u32 i;
    for (i = 0; i &lt; 12; i++)
    {
        boxMon-&gt;secure.raw[i] ^= boxMon-&gt;personality;
        boxMon-&gt;secure.raw[i] ^= boxMon-&gt;otId;
    }
}

static void DecryptBoxMon(struct BoxPokemon *boxMon)
{
    u32 i;
    for (i = 0; i &lt; 12; i++)
    {
        boxMon-&gt;secure.raw[i] ^= boxMon-&gt;otId;
        boxMon-&gt;secure.raw[i] ^= boxMon-&gt;personality;
    }
}
</code></pre>
<p>可以看到对加密区域的数据的加密是根据原值对<strong>otId</strong>和<strong>personality</strong>的异或得到的，这里并没有使用原来的encryptionKey来加密。那么想要动调找到宝可梦信息之后解密也就很简单了。</p>
<p>（坏蛋！）</p>
<figure data-type="image" tabindex="14"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/19/38e8c170bf72d.png" alt="1679221414711.png" loading="lazy"></figure>
<h2 id="提取背包宝可梦数据">提取背包宝可梦数据</h2>
<p>根据<code>gSaveBlock1Ptr</code>找到<code>gSaveBlock1</code>之后，往后0x34就是背包宝可梦的数量和宝可梦的信息了，比如我此时有两个宝可梦，小火龙和波波，他们的信息如下（小火龙从<code>020255AC</code>开始，波波从<code>02025610</code>开始）：</p>
<pre><code>020255A0 00 00 02 00 00 00 4F 00 02 00 00 00 8F 23 D0 32  ......O......#.2 
020255B0 1E 67 17 F7 BD C2 BB CC C7 BB C8 BE BF CC 02 02  .g.............. 
020255C0 C5 C9 CE C9 CC C3 FF 00 54 94 00 00 9B 44 EA C5  ........T....D.. 
020255D0 A5 44 C7 C5 B2 6C DE C5 95 44 C7 C5 EB 45 C7 C5  .D...l...D...E.. 
020255E0 91 12 C7 C5 91 1C C2 67 B4 BB C4 DC 91 44 C7 C5  .......g.....D.. 
020255F0 90 44 C6 C7 91 44 C7 C5 91 44 C7 C5 00 00 00 00  .D...D...D...... 
02025600 08 FF 18 00 18 00 0F 00 0C 00 0F 00 10 00 0D 00  ................ 
02025610 1B DD 46 D6 1E 67 17 F7 CA C3 BE C1 BF D3 FF 00  ..F..g.......... 
02025620 00 00 02 02 C5 C9 CE C9 CC C3 FF 00 E5 56 00 00  .............V.. 
02025630 05 DC 55 83 ED 5C 14 01 05 BA 51 21 15 BA 51 21  ..U..\....Q!..Q! 
02025640 65 BA 51 21 05 FD 51 21 05 BA 51 21 05 BA 51 21  e.Q!..Q!..Q!..Q! 
02025650 05 BA 51 21 24 BA 51 21 05 BA 51 21 26 BA 51 21  ..Q!$.Q!..Q!&amp;.Q! 
02025660 00 00 00 00 04 FF 11 00 11 00 09 00 09 00 08 00  ................ 
02025670 07 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
</code></pre>
<p>以小火龙的信息为例分析一下，<code>0x32D0238F</code>是他的性格，<code>0xF717671E</code>是otId，其中的<code>0x671E</code>是表id，也就是显示在训练家信息里的id，和我的26398刚好能对上。继续往后是昵称的编码，<code>CHARMANDER</code>对应的编码就是<code>BD C2 BB CC C7 BB C8 BE BF CC</code>这10个hex数据......</p>
<p>（pokemon的字符集并没有使用ASCII，而是他自己的一套）</p>
<p>一直分析到checksum之后，就会发现很难分析出信息了，这一块区域就是被<code>MON_DATA_ENCRYPT_SEPARATOR</code>分离出来的加密区域，再之后，到等级，现HP，最大HP，攻击力这些面板属性的位置又能通过明文看懂了。</p>
<h3 id="解密">解密</h3>
<p>动调<code>DecryptBoxMon</code>拿到的小火龙原始数据如下，</p>
<pre><code>02024280 00 00 00 00 8F 23 D0 32 1E 67 17 F7 BD C2 BB CC  .....#.2.g...... 
02024290 C7 BB C8 BE BF CC 02 02 C5 C9 CE C9 CC C3 FF 00  ................ 
020242A0 54 95 00 00 0A 00 2D 00 34 00 00 00 23 28 19 00  T....#.24...#(.. 
020242B0 04 00 00 00 7A 01 00 00 00 57 00 00 00 58 05 A2  ....z....W...X.. 
020242C0 25 FF 03 19 00 00 00 00 01 00 01 02 00 00 00 00  %............... 
020242D0 00 00 00 00 00 00 00 00 08 FF 18 00 18 00 0F 00  ................ 
020242E0 0C 00 0F 00 10 00 0D 00 1B DD 46 D6 1E 67 17 F7  ..........F..g.. 
</code></pre>
<p>现在就很清晰了，比如说<code>0x20242AC</code>处的<code>23 28 19 00</code>就分别代表它的4个技能的剩余PP值，又比如<code>0x20242C0</code>处的<code>0x1903FF25</code>就代表这只小火龙的个体值，按二进制展开来看如下</p>
<pre><code>00 01100 10000 00111 11111 11001 00101
非梦特 非蛋
特防: 12
特攻: 16
速度: 7
防御: 31 (V)
攻击: 25
生命: 5
</code></pre>
<p>结合源码就能相对容易的看出来需要的信息了。</p>
<h2 id="打造一只完美宝可梦">打造一只完美宝可梦</h2>
<p>至此，我们已经分析了一遍宝可梦数据的存储和反作弊机制，是时候小试牛刀，打造一个理想中的完美宝可梦了。</p>
<h3 id="闪光">闪光</h3>
<p>闪光（异色）这个概念对于常玩Pokemon系列游戏的玩家都不陌生，遇到一只闪光宝可梦的概率非常低，大概是1/4096，这就决定了它的逼格是非常高的。</p>
<p>因此，我们的第一个目标就是将我们的小火龙变成闪光小火龙。</p>
<p>细心的小伙伴会发现，之前的<code>Pokemon</code>结构体中好像并没有用于标记一个宝可梦是否闪光的变量，那么闪光究竟是如何判断的呢？</p>
<blockquote>
<p>从第三世代起，宝可梦是否异色不再与其能力挂钩，而是由ID No.、里ID No.、初训家以及性格值共同决定。</p>
<p>(ID No. xor 里ID No.) xor (性格值前16位 xor 性格值后16位) &lt; 8</p>
</blockquote>
<p>这是宝可梦百科对闪光的描述，并且我们分析的宝可梦火红正好是第三世代。</p>
<p>可以看出闪光只与otId和personality挂钩。</p>
<p>不想改personality是因为personality涉及到了几个substruct的指针构造，害怕出问题。所以我直接修改了里ID，</p>
<p>计算里ID的代码如下，</p>
<pre><code class="language-c">#include &lt;windows.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    unsigned int part1 = 0x115f;
    unsigned int otid = 0x671e0000;

    for (unsigned int i = 0; i&lt; 0xFFFFFF; ++i) {
        unsigned int pp = otid + i;
        unsigned int part2 = ((pp &gt;&gt; 16) &amp; 0xFFFF) ^ (pp &amp; 0xFFFF);
        if ((part1 ^ part2) &lt; 8) {
            printf(&quot;otId: 0x%x\n&quot;, pp);
            break;
        }
    }

    return 0;
}

/* otId: 0x671e7640 */
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/19/4c80e494d429b.png" alt="1679225726645.png" loading="lazy"></figure>
<h3 id="6v-进化-强力技能">6V &amp; 进化 &amp; 强力技能</h3>
<p>强度的大部分因素其实在<code>secure</code>保护下的几个结构体中，如果贸然改的话会导致checksum检查不通过，然后被变成badegg，经过辛苦的动调（内存断点下在小火龙的badegg位，然后跟进了一段时间），发现对checksum的比对是在<code>0x803FDBC</code>这个位置，那么我们只需要抢在系统判定之前把checksum修改为<code>CalculateBoxMonChecksum</code>计算出来的值就能绕过判断。</p>
<pre><code class="language-assembly">RAM:0803FDA6
RAM:0803FDA6                 MOVS            R5, R0
RAM:0803FDA8                 MOV             R0, R8
RAM:0803FDAA                 BL              sub_803F930
RAM:0803FDAE                 MOV             R0, R8
RAM:0803FDB0                 BL              loc_803E3FC
RAM:0803FDB4                 LSLS            R0, R0, #0x10
RAM:0803FDB6                 LSRS            R0, R0, #0x10
RAM:0803FDB8                 MOV             R1, R8
RAM:0803FDBA                 LDRH            R1, [R1,#0x1C]
RAM:0803FDBC                 CMP             R0, R1
RAM:0803FDBE                 BEQ             loc_803FDD6
RAM:0803FDC0                 MOV             R2, R8
RAM:0803FDC2                 LDRB            R0, [R2,#0x13]
RAM:0803FDC4                 MOVS            R1, #1
RAM:0803FDC6                 ORRS            R0, R1
RAM:0803FDC8                 MOVS            R1, #4
RAM:0803FDCA                 ORRS            R0, R1
RAM:0803FDCC                 STRB            R0, [R2,#0x13]
RAM:0803FDCE                 LDRB            R0, [R5,#7]
RAM:0803FDD0                 MOVS            R1, #0x40 ; '@'
RAM:0803FDD2                 ORRS            R0, R1
RAM:0803FDD4                 STRB            R0, [R5,#7]
</code></pre>
<p>这里我先让小火龙进化成喷火龙，也就是把species的4改成6，然后动调跟到对比小火龙checksum的部分，改掉对应的checksum值，即可绕过反作弊的检查。</p>
<figure data-type="image" tabindex="16"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/19/b8f8ff5162823.png" alt="1679226519852.png" loading="lazy"></figure>
<p>以此类推，我们还能让他变成6V宝可梦，只需要将原本的个体值<code>0x1903FF25</code>修改为<code>0x3FFFFFFF</code>。</p>
<p>我们还能找到存技能的位置，帮他配出来一些很牛逼的招式。这里给出我尝试的结果：</p>
<figure data-type="image" tabindex="17"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/03/19/54506ff78b90f.png" alt="1679228984639.png" loading="lazy"></figure>
<h1 id="0x03-总结">0x03 总结</h1>
<p>总的来说，这一次对Pokemon FireRed的逆向分析的完成度和预期差不多，不过分析出来的大部分逻辑都依赖了源码，动调找位置也依赖了符号表。在更多情况下的逆向分析并没有这么好的条件给我用，所以说还需要继续努力。学到了挺多基础的反作弊机制，也试着自己去思考着找到了绕过方法，收获颇丰！</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#0x00-%E6%8F%90%E5%8F%96gba%E7%9A%84binary">0x00 提取GBA的BINARY</a></li>
<li><a href="#0x01-%E5%AE%9E%E7%8E%B0%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E6%B5%85%E6%9E%90money%E5%8F%8D%E4%BD%9C%E5%BC%8A%E6%9C%BA%E5%88%B6">0x01 实现财富自由——浅析Money反作弊机制</a>
<ul>
<li><a href="#%E5%88%9D%E8%AF%95">初试</a></li>
<li><a href="#%E5%88%86%E6%9E%90">分析</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E5%88%A9%E7%94%A8">简单利用</a>
<ul>
<li><a href="#%E9%81%93%E5%85%B7%E6%98%AF%E6%88%91%E7%9A%84%E9%92%B1%E4%B9%9F%E6%98%AF%E6%88%91%E7%9A%84">道具是我的，钱也是我的</a></li>
<li><a href="#%E7%B2%BE%E5%87%86%E6%95%B0%E5%80%BC%E7%9A%84%E4%BF%AE%E6%94%B9">精准数值的修改</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%AE%E6%94%B9money%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%9D%E8%AF%95">自动化修改Money的一些尝试</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
<li><a href="#%E6%95%88%E6%9E%9C%E5%9B%BE">效果图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#0x02-%E5%BE%88%E9%9A%BE%E4%B8%8D%E8%B0%88%E7%9A%84%E5%8F%98%E5%BC%BA%E8%AF%9D%E9%A2%98%E8%8E%B7%E5%BE%97%E5%BC%BA%E5%8A%9B%E5%AE%9D%E5%8F%AF%E6%A2%A6">0x02 很难不谈的变强话题——获得强力宝可梦</a>
<ul>
<li><a href="#%E5%88%86%E6%9E%90-2">分析</a></li>
<li><a href="#%E6%8F%90%E5%8F%96%E8%83%8C%E5%8C%85%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%95%B0%E6%8D%AE">提取背包宝可梦数据</a>
<ul>
<li><a href="#%E8%A7%A3%E5%AF%86">解密</a></li>
</ul>
</li>
<li><a href="#%E6%89%93%E9%80%A0%E4%B8%80%E5%8F%AA%E5%AE%8C%E7%BE%8E%E5%AE%9D%E5%8F%AF%E6%A2%A6">打造一只完美宝可梦</a>
<ul>
<li><a href="#%E9%97%AA%E5%85%89">闪光</a></li>
<li><a href="#6v-%E8%BF%9B%E5%8C%96-%E5%BC%BA%E5%8A%9B%E6%8A%80%E8%83%BD">6V &amp; 进化 &amp; 强力技能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#0x03-%E6%80%BB%E7%BB%93">0x03 总结</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://kotoriseed.github.io/post/vnctf2023-pwn/">
              <h3 class="post-title">
                VNCTF2023出题手记
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://kotoriseed.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
